#!/bin/bash

HOVER_CONF="$HOME/.cache/navbar-hover.conf"
STATE="hidden"

# Function to read config
read_config() {
    TRIGGER_SIZE=10
    BAR_POSITION="top"
    [ -f "$HOVER_CONF" ] && source "$HOVER_CONF"
}

# Optimized monitor updates - call once and cache
update_monitors() {
    # Only call jq here to minimize process forking
    mapfile -t MONITORS < <(hyprctl monitors -j | jq -r '.[] | "\(.x) \(.y) \(.width) \(.height)"')
}

# Initial setup
if ! pgrep -x "waybar" >/dev/null; then
    waybar &
    sleep 0.5
fi

pkill -SIGUSR1 waybar
read_config
update_monitors

CYCLE_COUNT=0
while true; do
    ((CYCLE_COUNT++))
    if [ "$CYCLE_COUNT" -ge 50 ]; then
        read_config
        update_monitors
        CYCLE_COUNT=0
    fi


    IFS=', ' read -r CX CY < <(hyprctl cursorpos)

    IS_HOVERING=0
    for mon in "${MONITORS[@]}"; do
        read -r mx my mw mh <<< "$mon"
        
        # Optimized boundary checks using Bash math
        case "$BAR_POSITION" in
            "top")    (( CX >= mx && CX < mx + mw && CY >= my && CY <= my + TRIGGER_SIZE )) && IS_HOVERING=1 ;;
            "bottom") (( CX >= mx && CX < mx + mw && CY >= my + mh - TRIGGER_SIZE && CY <= my + mh )) && IS_HOVERING=1 ;;
            "left")   (( CX >= mx && CX <= mx + TRIGGER_SIZE && CY >= my && CY < my + mh )) && IS_HOVERING=1 ;;
            "right")  (( CX >= mx + mw - TRIGGER_SIZE && CX <= mx + mw && CY >= my && CY < my + mh )) && IS_HOVERING=1 ;;
        esac
        [ "$IS_HOVERING" -eq 1 ] && break
    done

    # State machine toggle to prevent spamming signals
    if [ "$IS_HOVERING" -eq 1 ] && [ "$STATE" = "hidden" ]; then
        pkill -SIGUSR1 waybar
        STATE="visible"
    elif [ "$IS_HOVERING" -eq 0 ] && [ "$STATE" = "visible" ]; then
        pkill -SIGUSR1 waybar
        STATE="hidden"
    fi

    sleep 0.1
done
